<LINK href="styles.css" rel="stylesheet" type="text/css"><div class="highlight"><pre><span class="c-Singleline">;?add 2010 modified by Tuncay to make it stdlib conform. </span>
<span class="c-Singleline">;?add Outcommented lines from autoexecution section.</span>
<span class="c-Singleline">;?add Added the prefix Eval_ to all functions now. </span>
<span class="c-Singleline">;?add Eval1() becomes Eval_1() and Fib() becomes Eval_Fib().</span>
<span class="c-Singleline">;?add Originally by Laszlo at http://www.autohotkey.com/forum/viewtopic.php?t=17058</span>

<span class="c-Singleline">; MONSTER Version 1.2 to EVALUATE ARITHMETIC EXPRESSIONS in strings (needs AHK 1.0.48+)</span>
<span class="c-Singleline">; Containing HEX, Signed Binary (&#39;11 = -1, &#39;011 = 3), scientific numbers (1.2e+5)</span>
<span class="c-Singleline">; Assignments :=, preceding an expression. E.g: a:=1; b:=2; a+b</span>
<span class="c-Singleline">; User defined functions: f(x) := expr;</span>
<span class="c-Singleline">; AHK Functions Abs|Ceil|Exp|Floor|Log|Ln|Round|Sqrt|Sin|Cos|Tan|ASin|ACos|ATan</span>
<span class="c-Singleline">; Predefined functions: SGN|Fib|Fac (sign, Fibonacci numbers, Factorials)</span>
<span class="c-Singleline">; &#39;(&#39;,&#39;)&#39;; Variables; Predefined operators GCD,MIN,MAX,Choose (2-parameter functions)</span>
<span class="c-Singleline">; Predefined constants: e, pi, inch, foot, mile, ounce, pint, gallon, oz, lb;</span>
<span class="c-Singleline">; Logic operators: !, ||, &amp;&amp;; ternary operator: (_?_:_);</span>
<span class="c-Singleline">; Relations: =,&lt;&gt;; &lt;,&gt;,&lt;=,&gt;=</span>
<span class="c-Singleline">; Binary operators: ~; |, ^, &amp;, &lt;&lt;, &gt;&gt;</span>
<span class="c-Singleline">; Arithmetic operators: +, -; *, /, \ (or % = mod); ** (or @ = power)</span>
<span class="c-Singleline">; Output FORMAT: $x,$h: Hex; $b{W}: W-bit binary;</span>
<span class="c-Singleline">;    ${k}: k-digit fixpoint,  ${k}e,${k}g: k-digit scientific (Default $6g)</span>

<span class="c-Singleline">;?out-begin</span>
<span class="cm">/*</span>
<span class="cm">#SingleInstance Force</span>
<span class="cm">#NoEnv</span>
<span class="cm">SetBatchLines -1</span>
<span class="cm">Process Priority,,High</span>

<span class="cm">xe := 2.718281828459045, xpi := 3.141592653589793      ; referenced as &quot;e&quot;, &quot;pi&quot;</span>
<span class="cm">xinch := 2.54, xfoot := 30.48, xmile := 1.609344       ; [cm], [cm], [Km]</span>
<span class="cm">xounce := 0.02841, xpint := 0.5682, xgallon := 4.54609 ; liters</span>
<span class="cm">xoz := 28.35, xlb := 453.59237                         ; gramms</span>
<span class="cm">*/</span><span class="c-Singleline"></span>
<span class="c-Singleline">;?out-end</span>

<span class="cm">/* -test cases</span>
<span class="cm">MsgBox % Eval(&quot;1e1&quot;)                                               ; 10</span>
<span class="cm">MsgBox % Eval(&quot;0x1E&quot;)                                              ; 30</span>
<span class="cm">MsgBox % Eval(&quot;ToBin(35)&quot;)                                         ; 100011</span>
<span class="cm">MsgBox % Eval(&quot;$b 35&quot;)                                             ; 0100011</span>
<span class="cm">MsgBox % Eval(&quot;&#39;10010&quot;)                                            ; -14</span>
<span class="cm">MsgBox % Eval(&quot;2&gt;3 ? 9 : 7&quot;)                                       ; 7</span>
<span class="cm">MsgBox % Eval(&quot;$2E 1e3 -50.0e+0 + 100.e-1&quot;)                        ; 9.60E+002</span>
<span class="cm">MsgBox % Eval(&quot;fact(x) := x &lt; 2 ? 1 : x*fact(x-1); fact(5)&quot;)       ; 120</span>
<span class="cm">MsgBox % Eval(&quot;f(ab):=sqrt(ab)/ab; y:=f(2); ff(y):=y*(y-1)/2/x; x := 2; y+ff(3)/f(16)&quot;) ; 6.70711</span>
<span class="cm">MsgBox % Eval(&quot;x := qq:1; x := 5*x; y := x+1&quot;)                     ; 6 [if y empty, x := 1...]</span>
<span class="cm">MsgBox % Eval(&quot;x:=-!0; x&lt;0 ? 2*x : sqrt(x)&quot;)                       ; -2</span>
<span class="cm">MsgBox % Eval(&quot;tan(atan(atan(tan(1))))-exp(sqrt(1))&quot;)              ; -1.71828</span>
<span class="cm">MsgBox % Eval(&quot;---2+++9 + ~-2 --1 -2*-3&quot;)                          ; 15</span>
<span class="cm">MsgBox % Eval(&quot;x1:=1; f1:=sin(x1)/x1; y:=2; f2:=sin(y)/y; f1/f2&quot;)  ; 1.85082</span>
<span class="cm">MsgBox % Eval(&quot;Round(fac(10)/fac(5)**2) - (10 choose 5) + Fib(8)&quot;) ; 21</span>
<span class="cm">MsgBox % Eval(&quot;1 min-1 min-2 min 2&quot;)                               ; -2</span>
<span class="cm">MsgBox % Eval(&quot;(-1&gt;&gt;1&lt;=9 &amp;&amp; 3&gt;2)&lt;&lt;2&gt;&gt;1&quot;)                           ; 2</span>
<span class="cm">MsgBox % Eval(&quot;(1 = 1) + (2&lt;&gt;3 || 2 &lt; 1) + (9&gt;=-1 &amp;&amp; 3&gt;2)&quot;)        ; 3</span>
<span class="cm">MsgBox % Eval(&quot;$b6 -21/3&quot;)                                         ; 111001</span>
<span class="cm">MsgBox % Eval(&quot;$b (&#39;1001 &lt;&lt; 5) | &#39;01000&quot;)                          ; 100101000</span>
<span class="cm">MsgBox % Eval(&quot;$0 194*lb/1000&quot;)                                    ; 88 [Kg]</span>
<span class="cm">MsgBox % Eval(&quot;$x ~0xfffffff0 &amp; 7 | 0x100 &lt;&lt; 2&quot;)                   ; 0x407</span>
<span class="cm">MsgBox % Eval(&quot;- 1 * (+pi -((3%5))) +pi+ 1-2 + e-ROUND(abs(sqrt(floor(2)))**2)-e+pi $9&quot;) ; 3.141592654</span>
<span class="cm">MsgBox % Eval(&quot;(20+4 GCD abs(2**4)) + (9 GCD (6 CHOOSE 2))&quot;)       ; 11</span>
<span class="cm">t := A_TickCount</span>
<span class="cm">Loop 1000</span>
<span class="cm">   r := Eval(&quot;x:=&quot; A_Index/1000 &quot;;atan(x)-exp(sqrt(x))&quot;)           ; simulated plot</span>
<span class="cm">t := A_TickCount - t</span>
<span class="cm">MsgBox Result = %r%`nTime = %t%                                    ; -1.93288: ~400 ms [on Inspiron 9300]</span>
<span class="cm">*/</span><span class="c-Singleline"></span>

<span class="c-Singleline">;?out-begin</span>
<span class="cm">/*</span>
<span class="cm">^#-::                                  ; Replace selection or `expression with result</span>
<span class="cm">^#=::                                  ; Append result to selection or `expression</span>
<span class="cm">   ClipBoard =</span>
<span class="cm">   SendInput ^c                        ; copy selection</span>
<span class="cm">   ClipWait 0.5</span>
<span class="cm">   If (ErrorLevel) {</span>
<span class="cm">      SendInput +{HOME}^c              ; copy, keep selection to overwrite (^x for some apps)</span>
<span class="cm">      ClipWait 1</span>
<span class="cm">      IfEqual ErrorLevel,1, Return</span>
<span class="cm">      If RegExMatch(ClipBoard, &quot;(.*)(``)(.*)&quot;, y)</span>
<span class="cm">         SendInput %  &quot;{RAW}&quot; y1 . (A_ThisHotKey=&quot;^#=&quot; ? y3 . &quot; = &quot;  : &quot;&quot;) . Eval(y3)</span>
<span class="cm">   } Else</span>
<span class="cm">      SendInput % &quot;{RAW}&quot; . (A_ThisHotKey=&quot;^#=&quot; ? ClipBoard . &quot; = &quot;  : &quot;&quot;) . Eval(ClipBoard)</span>
<span class="cm">Return</span>
<span class="cm">*/</span><span class="c-Singleline"></span>
<span class="c-Singleline">;?out-end</span>

<span class="n">Eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">                              ; non-recursive PRE/POST PROCESSING: I/O forms, numbers, ops, &quot;;&quot;</span>
   <span class="n">Local</span> <span class="n">FORM</span><span class="p">,</span> <span class="n">FormF</span><span class="p">,</span> <span class="n">FormI</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">y4</span>
   <span class="n">FormI</span> :<span class="o">=</span> <span class="nv">A_FormatInteger</span><span class="p">,</span> <span class="n">FormF</span> :<span class="o">=</span> <span class="nv">A_FormatFloat</span>

<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">D</span><span class="c-Singleline">                ; decimal intermediate results!</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;\$(b|h|x|)(\d*[eEgG]?)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
   <span class="n">FORM</span> :<span class="o">=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">W</span> :<span class="o">=</span> <span class="n">y2</span><span class="c-Singleline">                 ; HeX, Bin, .{digits} output format</span>
<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="mf">0.16</span><span class="n">e</span><span class="c-Singleline">              ; Full intermediate float precision</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">%y%</span><span class="c-Singleline">             ; remove $..</span>
<span class="w">   </span><span class="nb">Loop</span>
<span class="w">      </span><span class="nb">If </span><span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;i)(.*)(0x[a-f\d]*)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
         <span class="n">x</span> :<span class="o">=</span> <span class="n">y1</span> <span class="o">.</span> <span class="n">y2</span><span class="o">+</span><span class="mi">0</span> <span class="o">.</span> <span class="n">y3</span><span class="c-Singleline">           ; convert hex numbers to decimal</span>
<span class="w">      </span><span class="nb">Else</span> <span class="n">Break</span>
<span class="w">   </span><span class="nb">Loop</span>
<span class="w">      </span><span class="nb">If </span><span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)&#39;([01]*)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
         <span class="n">x</span> :<span class="o">=</span> <span class="n">y1</span> <span class="o">.</span> <span class="n">Eval_FromBin</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span> <span class="o">.</span> <span class="n">y3</span><span class="c-Singleline">    ; convert binary numbers to decimal: sign = first bit</span>
<span class="w">      </span><span class="nb">Else</span> <span class="n">Break</span>
   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;(^|[^.\d])(\d+)(e|E)&quot;</span><span class="p">,</span><span class="s">&quot;$1$2.$3&quot;</span><span class="p">)</span><span class="c-Singleline"> ; add missing &#39;.&#39; before E (1e3 -&gt; 1.e3)</span>
<span class="c-Singleline">                                       ; literal scientific numbers between  and  chars</span>
   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;(\d*\.\d*|\d)([eE][+-]?\d+)&quot;</span><span class="p">,</span><span class="s">&quot;$1$2&quot;</span><span class="p">)</span>

<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>`<span class="o">%</span><span class="p">,</span> \<span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; %  -&gt; \ (= MOD)</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="p">,</span>@<span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; ** -&gt; @ for easier process</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">+</span><span class="p">,</span> ±<span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; ± is addition</span>
   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([^]*)±&quot;</span><span class="p">,</span><span class="s">&quot;$1+&quot;</span><span class="p">)</span><span class="c-Singleline"> ; ...not inside literal numbers</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="p">,</span> ¬<span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; ¬ is subtraction</span>
   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([^]*)¬&quot;</span><span class="p">,</span><span class="s">&quot;$1-&quot;</span><span class="p">)</span><span class="c-Singleline"> ; ...not inside literal numbers</span>

<span class="w">   </span><span class="nb">Loop</span> <span class="n">Parse</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> `<span class="p">;</span>
      <span class="n">y</span> :<span class="o">=</span> <span class="n">Eval_1</span><span class="p">(</span><span class="nv">A_LoopField</span><span class="p">)</span><span class="c-Singleline">          ; work on pre-processed sub expressions</span>
<span class="c-Singleline">                                       ; return result of last sub-expression (numeric)</span>
<span class="w">   </span><span class="nb">If </span><span class="n">FORM</span> <span class="o">=</span> <span class="n">b</span><span class="c-Singleline">                         ; convert output to binary</span>
      <span class="n">y</span> :<span class="o">=</span> <span class="n">W</span> ? <span class="n">Eval_ToBinW</span><span class="p">(</span><span class="nf">Round(</span><span class="n">y</span><span class="p">),</span><span class="n">W</span><span class="p">)</span> : <span class="n">Eval_ToBin</span><span class="p">(</span><span class="nf">Round(</span><span class="n">y</span><span class="p">))</span>
<span class="w">   </span><span class="nb">Else</span> <span class="n">If</span> <span class="p">(</span><span class="n">FORM</span><span class="o">=</span><span class="s">&quot;h&quot;</span> <span class="ow">or</span> <span class="n">FORM</span><span class="o">=</span><span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="w">      </span><span class="nb">SetFormat</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Hex</span><span class="c-Singleline">           ; convert output to hex</span>
      <span class="n">y</span> :<span class="o">=</span> <span class="nf">Round(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span>
   <span class="p">}</span>
<span class="w">   </span><span class="nb">Else</span> <span class="p">{</span>
      <span class="n">W</span> :<span class="o">=</span> <span class="n">W</span><span class="o">=</span><span class="s">&quot;&quot;</span> ? <span class="s">&quot;0.6g&quot;</span> : <span class="s">&quot;0.&quot;</span> <span class="o">.</span> <span class="n">W</span><span class="c-Singleline">    ; Set output form, Default = 6 decimal places</span>
<span class="w">      </span><span class="nb">SetFormat</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="nv">%W%</span>
      <span class="n">y</span> <span class="o">+=</span> <span class="mf">0.0</span>
   <span class="p">}</span>
<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">Integer</span><span class="p">,</span> <span class="nv">%FormI%</span><span class="c-Singleline">          ; restore original formats</span>
<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">FLOAT</span><span class="p">,</span>   <span class="nv">%FormF%</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">y</span>
<span class="p">}</span>

<span class="n">Eval_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">                             ; recursive PREPROCESSING of :=, vars, (..) [decimal, no &quot;;&quot;]</span>
   <span class="n">Local</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; save function definition: f(x) := expr</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(\S*?)\((.*?)\)\s*:=\s*(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">f</span><span class="nv">%y1%</span><span class="n">__X</span> :<span class="o">=</span> <span class="n">y2</span><span class="p">,</span> <span class="n">f</span><span class="nv">%y1%</span><span class="n">__F</span> :<span class="o">=</span> <span class="n">y3</span>
<span class="w">      </span><span class="nb">Return</span>
   <span class="p">}</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute leftmost &quot;:=&quot; operator of a := b := ...</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(\S*?)\s*:=\s*(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">y</span> :<span class="o">=</span> <span class="s">&quot;x&quot;</span> <span class="o">.</span> <span class="n">y1</span><span class="c-Singleline">                    ; user vars internally start with x to avoid name conflicts</span>
<span class="w">      </span><span class="nb">Return</span> <span class="nv">%y%</span> :<span class="o">=</span> <span class="n">Eval_1</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
   <span class="p">}</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; here: no variable to the left of last &quot;:=&quot;</span>
   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([\).\w]\s+|[\)])([a-z_A-Z]+)&quot;</span><span class="p">,</span><span class="s">&quot;$1«$2»&quot;</span><span class="p">)</span><span class="c-Singleline">  ; op -&gt; «op»</span>

   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;\s+&quot;</span><span class="p">)</span><span class="c-Singleline">          ; remove spaces, tabs, newlines</span>

   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([a-z_A-Z]\w*)\(&quot;</span><span class="p">,</span><span class="s">&quot;&#39;$1&#39;(&quot;</span><span class="p">)</span><span class="c-Singleline"> ; func( -&gt; &#39;func&#39;( to avoid atan|tan conflicts</span>

   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([a-z_A-Z]\w*)([^\w&#39;»]|$)&quot;</span><span class="p">,</span><span class="s">&quot;%x$1%$2&quot;</span><span class="p">)</span><span class="c-Singleline"> ; VAR -&gt; %xVAR%</span>
   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([^]*)%x[eE]%&quot;</span><span class="p">,</span><span class="s">&quot;$1e&quot;</span><span class="p">)</span><span class="c-Singleline"> ; in numbers %xe% -&gt; e</span>
   <span class="n">x</span> :<span class="o">=</span> <span class="nf">RegExReplace(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;|&quot;</span><span class="p">)</span><span class="c-Singleline">          ; no more need for number markers</span>
<span class="w">   </span><span class="nb">Transform</span> <span class="n">x</span><span class="p">,</span> <span class="n">Deref</span><span class="p">,</span> <span class="nv">%x%</span><span class="c-Singleline">             ; dereference all right-hand-side %var%-s</span>

<span class="w">   </span><span class="nb">Loop</span> <span class="p">{</span><span class="c-Singleline">                              ; find last innermost (..)</span>
<span class="w">      </span><span class="nb">If </span><span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)\(([^\(\)]*)\)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
         <span class="n">x</span> :<span class="o">=</span> <span class="n">y1</span> <span class="o">.</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y2</span><span class="p">)</span> <span class="o">.</span> <span class="n">y3</span><span class="c-Singleline">      ; replace (x) with value of x</span>
<span class="w">      </span><span class="nb">Else</span> <span class="n">Break</span>
   <span class="p">}</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">Eval_</span>@<span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">                             ; EVALUATE PRE-PROCESSED EXPRESSIONS [decimal, NO space, vars, (..), &quot;;&quot;, &quot;:=&quot;]</span>
   <span class="n">Local</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">y4</span>

<span class="w">   </span><span class="nb">If </span><span class="n">x</span> <span class="ow">is</span> <span class="n">number</span><span class="c-Singleline">                      ; no more operators left</span>
<span class="w">      </span><span class="nb">Return</span> <span class="n">x</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost ?,: operator</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(\?|:)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>?<span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> ? <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span> : <span class="s">&quot;&quot;</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>:<span class="p">,</span>  <span class="n">Return</span> <span class="p">((</span><span class="n">y</span> :<span class="o">=</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">))</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> ? <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span> : <span class="n">y</span><span class="p">)</span>

<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">||</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">            ; execute rightmost || operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">||</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">            ; execute rightmost &amp;&amp; operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost =, &lt;&gt; operator</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(?&lt;![\&lt;\&gt;])(\&lt;\&gt;|=)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">=</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">=</span>  <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost &lt;,&gt;,&lt;=,&gt;= operator</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(?&lt;![\&lt;\&gt;])(\&lt;=?|\&gt;=?)(?![\&lt;\&gt;])(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;</span>  <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&gt;</span>  <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;=</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&gt;=</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost user operator (low precedence)</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;i)(.*)«(.*?)»(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">IsFunc(</span><span class="n">y2</span><span class="p">)</span>
<span class="w">      </span><span class="nb">Return</span> <span class="nv">%y2%</span><span class="p">(</span><span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">),</span><span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">))</span><span class="c-Singleline"> ; predefined relational ops</span>

<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">|</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">             ; execute rightmost | operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">|</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">^</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">             ; execute rightmost ^ operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">             ; execute rightmost &amp; operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost &lt;&lt;, &gt;&gt; operator</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(\&lt;\&lt;|\&gt;\&gt;)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost +- (not unary) operator</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*[^!\~±¬\@\*/\\])(±|¬)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="c-Singleline"> ; lower precedence ops already handled</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>±<span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>¬<span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost */% operator</span>
   <span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(\*|/|\\)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">*</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">/</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>\<span class="p">,</span>  <span class="n">Return</span> <span class="nf">Mod(</span><span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span><span class="p">),</span><span class="n">Eval_</span>@<span class="p">(</span><span class="n">y3</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost power</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> @<span class="p">,</span> <span class="n">R</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">**</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="nf">SubStr(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost function, unary operator</span>
   <span class="n">If</span> !<span class="nf">RegExMatch(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;(.*)(!|±|¬|~|&#39;(.*)&#39;)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">      </span><span class="nb">Return</span> <span class="n">x</span><span class="c-Singleline">                         ; no more function (y1 &lt;&gt; &quot;&quot; only at multiple unaries: --+-)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>!<span class="p">,</span><span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span> <span class="o">.</span> !<span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary !</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>±<span class="p">,</span><span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span> <span class="o">.</span>  <span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary +</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>¬<span class="p">,</span><span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="o">-</span><span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary - (they behave like functions)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">~</span><span class="p">,</span><span class="n">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="o">~</span><span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary ~</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">IsFunc(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">      </span><span class="nb">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="nv">%y3%</span><span class="p">(</span><span class="n">y4</span><span class="p">))</span><span class="c-Singleline">      ; built-in and predefined functions(y4)</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">Eval_</span>@<span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="n">Eval_1</span><span class="p">(</span><span class="nf">RegExReplace(</span><span class="n">f</span><span class="nv">%y3%</span><span class="n">__F</span><span class="p">,</span> <span class="n">f</span><span class="nv">%y3%</span><span class="n">__X</span><span class="p">,</span> <span class="n">y4</span><span class="p">)))</span><span class="c-Singleline"> ; LAST: user defined functions</span>
<span class="p">}</span>

<span class="n">Eval_ToBin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">      ; Binary representation of n. 1st bit is SIGN: -8 -&gt; 1000, -1 -&gt; 1, 0 -&gt; 0, 8 -&gt; 01000</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="o">||</span><span class="n">n</span><span class="o">=-</span><span class="mi">1</span> ? <span class="o">-</span><span class="n">n</span> : <span class="n">Eval_ToBin</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">.</span> <span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span>
<span class="p">}</span>
<span class="n">Eval_ToBinW</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline"> ; LS W-bits of Binary representation of n</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="nv">%W%</span><span class="c-Singleline">     ; Recursive (slower): Return W=1 ? n&amp;1 : ToBinW(n&gt;&gt;1,W-1) . n&amp;1</span>
      <span class="n">b</span> :<span class="o">=</span> <span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">.</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">b</span>
<span class="p">}</span>
<span class="n">Eval_FromBin</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline"> ; Number converted from the binary &quot;bits&quot; string, 1st bit is SIGN</span>
   <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="n">Parse</span><span class="p">,</span> <span class="n">bits</span>
      <span class="n">n</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">+</span> <span class="nv">A_LoopField</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="nf">SubStr(</span><span class="n">bits</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="nf">StrLen(</span><span class="n">bits</span><span class="p">))</span>
<span class="p">}</span>

<span class="n">Eval_Sgn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
<span class="w">   </span><span class="nb">Return</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">Eval_MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span> ? <span class="n">a</span> : <span class="n">b</span>
<span class="p">}</span>
<span class="n">Eval_MAX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span> ? <span class="n">b</span> : <span class="n">a</span>
<span class="p">}</span>
<span class="n">Eval_GCD</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">      ; Euclidean GCD</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span> ? <span class="nf">Abs(</span><span class="n">a</span><span class="p">)</span> : <span class="n">Eval_GCD</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nf">mod(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="p">}</span>
<span class="n">Eval_Choose</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">   ; Binomial coefficient</span>
   <span class="n">p</span> :<span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> :<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> :<span class="o">=</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span> ? <span class="n">k</span> : <span class="n">n</span><span class="o">-</span><span class="n">k</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="nv">%k%</span><span class="c-Singleline">                   ; Recursive (slower): Return k = 0 ? 1 : Choose(n-1,k-1)*n//k</span>
      <span class="n">p</span> <span class="o">*=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="c-Singleline">  ; FOR INTEGERS: p *= n-i, p //= ++i</span>
<span class="w">   </span><span class="nb">Return</span> <span class="nf">Round(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">Eval_Fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">        ; n-th Fibonacci number (n &lt; 0 OK, iterative to avoid globals)</span>
   <span class="n">a</span> :<span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> :<span class="o">=</span> <span class="mi">1</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="o">%</span> <span class="nf">abs(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
      <span class="n">c</span> :<span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> :<span class="o">=</span> <span class="n">c</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span> ? <span class="mi">0</span> : <span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span> ? <span class="n">b</span> : <span class="o">-</span><span class="n">b</span>
<span class="p">}</span>
<span class="n">Eval_fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">        ; n!</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> ? <span class="mi">1</span> : <span class="n">n</span><span class="o">*</span><span class="n">Eval_fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
