<LINK href="styles.css" rel="stylesheet" type="text/css">old lexer: 
<div class="highlight"><pre><span class="c1">;?add 2010 modified by Tuncay to make it stdlib conform. </span>
<span class="c1">;?add Outcommented lines from autoexecution section.</span>
<span class="c1">;?add Added the prefix Eval_ to all functions now. </span>
<span class="c1">;?add Eval1() becomes Eval_1() and Fib() becomes Eval_Fib().</span>
<span class="c1">;?add Originally by Laszlo at http://www.autohotkey.com/forum/viewtopic.php?t=17058</span>

<span class="c1">; MONSTER Version 1.2 to EVALUATE ARITHMETIC EXPRESSIONS in strings (needs AHK 1.0.48+)</span>
<span class="c1">; Containing HEX, Signed Binary (&#39;11 = -1, &#39;011 = 3), scientific numbers (1.2e+5)</span>
<span class="c1">; Assignments :=, preceding an expression. E.g: a:=1; b:=2; a+b</span>
<span class="c1">; User defined functions: f(x) := expr;</span>
<span class="c1">; AHK Functions Abs|Ceil|Exp|Floor|Log|Ln|Round|Sqrt|Sin|Cos|Tan|ASin|ACos|ATan</span>
<span class="c1">; Predefined functions: SGN|Fib|Fac (sign, Fibonacci numbers, Factorials)</span>
<span class="c1">; &#39;(&#39;,&#39;)&#39;; Variables; Predefined operators GCD,MIN,MAX,Choose (2-parameter functions)</span>
<span class="c1">; Predefined constants: e, pi, inch, foot, mile, ounce, pint, gallon, oz, lb;</span>
<span class="c1">; Logic operators: !, ||, &amp;&amp;; ternary operator: (_?_:_);</span>
<span class="c1">; Relations: =,&lt;&gt;; &lt;,&gt;,&lt;=,&gt;=</span>
<span class="c1">; Binary operators: ~; |, ^, &amp;, &lt;&lt;, &gt;&gt;</span>
<span class="c1">; Arithmetic operators: +, -; *, /, \ (or % = mod); ** (or @ = power)</span>
<span class="c1">; Output FORMAT: $x,$h: Hex; $b{W}: W-bit binary;</span>
<span class="c1">;    ${k}: k-digit fixpoint,  ${k}e,${k}g: k-digit scientific (Default $6g)</span>

<span class="c1">;?out-begin</span>
<span class="cm">/*</span>
<span class="cm">#SingleInstance Force</span>
<span class="cm">#NoEnv</span>
<span class="cm">SetBatchLines -1</span>
<span class="cm">Process Priority,,High</span>

<span class="cm">xe := 2.718281828459045, xpi := 3.141592653589793      ; referenced as &quot;e&quot;, &quot;pi&quot;</span>
<span class="cm">xinch := 2.54, xfoot := 30.48, xmile := 1.609344       ; [cm], [cm], [Km]</span>
<span class="cm">xounce := 0.02841, xpint := 0.5682, xgallon := 4.54609 ; liters</span>
<span class="cm">xoz := 28.35, xlb := 453.59237                         ; gramms</span>
<span class="cm">*/</span>
<span class="c1">;?out-end</span>

<span class="cm">/* -test cases</span>
<span class="cm">MsgBox % Eval(&quot;1e1&quot;)                                               ; 10</span>
<span class="cm">MsgBox % Eval(&quot;0x1E&quot;)                                              ; 30</span>
<span class="cm">MsgBox % Eval(&quot;ToBin(35)&quot;)                                         ; 100011</span>
<span class="cm">MsgBox % Eval(&quot;$b 35&quot;)                                             ; 0100011</span>
<span class="cm">MsgBox % Eval(&quot;&#39;10010&quot;)                                            ; -14</span>
<span class="cm">MsgBox % Eval(&quot;2&gt;3 ? 9 : 7&quot;)                                       ; 7</span>
<span class="cm">MsgBox % Eval(&quot;$2E 1e3 -50.0e+0 + 100.e-1&quot;)                        ; 9.60E+002</span>
<span class="cm">MsgBox % Eval(&quot;fact(x) := x &lt; 2 ? 1 : x*fact(x-1); fact(5)&quot;)       ; 120</span>
<span class="cm">MsgBox % Eval(&quot;f(ab):=sqrt(ab)/ab; y:=f(2); ff(y):=y*(y-1)/2/x; x := 2; y+ff(3)/f(16)&quot;) ; 6.70711</span>
<span class="cm">MsgBox % Eval(&quot;x := qq:1; x := 5*x; y := x+1&quot;)                     ; 6 [if y empty, x := 1...]</span>
<span class="cm">MsgBox % Eval(&quot;x:=-!0; x&lt;0 ? 2*x : sqrt(x)&quot;)                       ; -2</span>
<span class="cm">MsgBox % Eval(&quot;tan(atan(atan(tan(1))))-exp(sqrt(1))&quot;)              ; -1.71828</span>
<span class="cm">MsgBox % Eval(&quot;---2+++9 + ~-2 --1 -2*-3&quot;)                          ; 15</span>
<span class="cm">MsgBox % Eval(&quot;x1:=1; f1:=sin(x1)/x1; y:=2; f2:=sin(y)/y; f1/f2&quot;)  ; 1.85082</span>
<span class="cm">MsgBox % Eval(&quot;Round(fac(10)/fac(5)**2) - (10 choose 5) + Fib(8)&quot;) ; 21</span>
<span class="cm">MsgBox % Eval(&quot;1 min-1 min-2 min 2&quot;)                               ; -2</span>
<span class="cm">MsgBox % Eval(&quot;(-1&gt;&gt;1&lt;=9 &amp;&amp; 3&gt;2)&lt;&lt;2&gt;&gt;1&quot;)                           ; 2</span>
<span class="cm">MsgBox % Eval(&quot;(1 = 1) + (2&lt;&gt;3 || 2 &lt; 1) + (9&gt;=-1 &amp;&amp; 3&gt;2)&quot;)        ; 3</span>
<span class="cm">MsgBox % Eval(&quot;$b6 -21/3&quot;)                                         ; 111001</span>
<span class="cm">MsgBox % Eval(&quot;$b (&#39;1001 &lt;&lt; 5) | &#39;01000&quot;)                          ; 100101000</span>
<span class="cm">MsgBox % Eval(&quot;$0 194*lb/1000&quot;)                                    ; 88 [Kg]</span>
<span class="cm">MsgBox % Eval(&quot;$x ~0xfffffff0 &amp; 7 | 0x100 &lt;&lt; 2&quot;)                   ; 0x407</span>
<span class="cm">MsgBox % Eval(&quot;- 1 * (+pi -((3%5))) +pi+ 1-2 + e-ROUND(abs(sqrt(floor(2)))**2)-e+pi $9&quot;) ; 3.141592654</span>
<span class="cm">MsgBox % Eval(&quot;(20+4 GCD abs(2**4)) + (9 GCD (6 CHOOSE 2))&quot;)       ; 11</span>
<span class="cm">t := A_TickCount</span>
<span class="cm">Loop 1000</span>
<span class="cm">   r := Eval(&quot;x:=&quot; A_Index/1000 &quot;;atan(x)-exp(sqrt(x))&quot;)           ; simulated plot</span>
<span class="cm">t := A_TickCount - t</span>
<span class="cm">MsgBox Result = %r%`nTime = %t%                                    ; -1.93288: ~400 ms [on Inspiron 9300]</span>
<span class="cm">*/</span>

<span class="c1">;?out-begin</span>
<span class="cm">/*</span>
<span class="cm">^#-::                                  ; Replace selection or `expression with result</span>
<span class="cm">^#=::                                  ; Append result to selection or `expression</span>
<span class="cm">   ClipBoard =</span>
<span class="cm">   SendInput ^c                        ; copy selection</span>
<span class="cm">   ClipWait 0.5</span>
<span class="cm">   If (ErrorLevel) {</span>
<span class="cm">      SendInput +{HOME}^c              ; copy, keep selection to overwrite (^x for some apps)</span>
<span class="cm">      ClipWait 1</span>
<span class="cm">      IfEqual ErrorLevel,1, Return</span>
<span class="cm">      If RegExMatch(ClipBoard, &quot;(.*)(``)(.*)&quot;, y)</span>
<span class="cm">         SendInput %  &quot;{RAW}&quot; y1 . (A_ThisHotKey=&quot;^#=&quot; ? y3 . &quot; = &quot;  : &quot;&quot;) . Eval(y3)</span>
<span class="cm">   } Else</span>
<span class="cm">      SendInput % &quot;{RAW}&quot; . (A_ThisHotKey=&quot;^#=&quot; ? ClipBoard . &quot; = &quot;  : &quot;&quot;) . Eval(ClipBoard)</span>
<span class="cm">Return</span>
<span class="cm">*/</span>
<span class="c1">;?out-end</span>

<span class="nf">Eval</span><span class="p">(</span>x<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                              </span><span class="c1">; non-recursive PRE/POST PROCESSING: I/O forms, numbers, ops, &quot;;&quot;</span>
<span class="w">   </span><span class="kt">Local</span><span class="w"> </span>FORM<span class="p">,</span><span class="w"> </span>FormF<span class="p">,</span><span class="w"> </span>FormI<span class="p">,</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>W<span class="p">,</span><span class="w"> </span>y<span class="p">,</span><span class="w"> </span>y1<span class="p">,</span><span class="w"> </span>y2<span class="p">,</span><span class="w"> </span>y3<span class="p">,</span><span class="w"> </span>y4
<span class="w">   </span>FormI<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">A_FormatInteger</span><span class="p">,</span><span class="w"> </span>FormF<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">A_FormatFloat</span>

<span class="w">   </span><span class="k">SetFormat</span><span class="w"> </span>Integer<span class="p">,</span><span class="w"> </span>D<span class="w">                </span><span class="c1">; decimal intermediate results!</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;\$(b|h|x|)(\d*[eEgG]?)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">   </span>FORM<span class="w"> </span><span class="o">:=</span><span class="w"> </span>y1<span class="p">,</span><span class="w"> </span>W<span class="w"> </span><span class="o">:=</span><span class="w"> </span>y2<span class="w">                 </span><span class="c1">; HeX, Bin, .{digits} output format</span>
<span class="w">   </span><span class="k">SetFormat</span><span class="w"> </span>FLOAT<span class="p">,</span><span class="w"> </span><span class="mf">0.16</span>e<span class="w">              </span><span class="c1">; Full intermediate float precision</span>
<span class="w">   </span><span class="k">StringReplace</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="nv">%y%</span><span class="w">             </span><span class="c1">; remove $..</span>
<span class="w">   </span><span class="k">Loop</span>
<span class="w">      </span><span class="kr">If</span><span class="w"> </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;i)(.*)(0x[a-f\d]*)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">         </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span>y2<span class="o">+</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="w"> </span>y3<span class="w">           </span><span class="c1">; convert hex numbers to decimal</span>
<span class="w">      </span><span class="k">Else</span><span class="w"> </span><span class="k">Break</span>
<span class="w">   </span><span class="k">Loop</span>
<span class="w">      </span><span class="kr">If</span><span class="w"> </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*)&#39;([01]*)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">         </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span>Eval_FromBin<span class="p">(</span>y2<span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="w"> </span>y3<span class="w">    </span><span class="c1">; convert binary numbers to decimal: sign = first bit</span>
<span class="w">      </span><span class="k">Else</span><span class="w"> </span><span class="k">Break</span>
<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;(^|[^.\d])(\d+)(e|E)&quot;</span><span class="p">,</span><span class="s">&quot;$1$2.$3&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; add missing &#39;.&#39; before E (1e3 -&gt; 1.e3)</span>
<span class="w">                                       </span><span class="c1">; literal scientific numbers between  and  chars</span>
<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;(\d*\.\d*|\d)([eE][+-]?\d+)&quot;</span><span class="p">,</span><span class="s">&quot;$1$2&quot;</span><span class="p">)</span>

<span class="w">   </span><span class="k">StringReplace</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span>x<span class="p">,`</span><span class="o">%</span><span class="p">,</span><span class="w"> </span><span class="p">\,</span><span class="w"> </span>All<span class="w">       </span><span class="c1">; %  -&gt; \ (= MOD)</span>
<span class="w">   </span><span class="k">StringReplace</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="p">,</span><span class="err">@</span><span class="p">,</span><span class="w"> </span>All<span class="w">       </span><span class="c1">; ** -&gt; @ for easier process</span>
<span class="w">   </span><span class="k">StringReplace</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="err">±</span><span class="p">,</span><span class="w"> </span>All<span class="w">       </span><span class="c1">; ± is addition</span>
<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;([^]*)±&quot;</span><span class="p">,</span><span class="s">&quot;$1+&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ...not inside literal numbers</span>
<span class="w">   </span><span class="k">StringReplace</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">,</span><span class="w"> </span><span class="err">¬</span><span class="p">,</span><span class="w"> </span>All<span class="w">       </span><span class="c1">; ¬ is subtraction</span>
<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;([^]*)¬&quot;</span><span class="p">,</span><span class="s">&quot;$1-&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ...not inside literal numbers</span>

<span class="w">   </span><span class="k">Loop</span><span class="w"> </span>Parse<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="p">`;</span>
<span class="w">      </span>y<span class="w"> </span><span class="o">:=</span><span class="w"> </span>Eval_1<span class="p">(</span><span class="nb">A_LoopField</span><span class="p">)</span><span class="w">          </span><span class="c1">; work on pre-processed sub expressions</span>
<span class="w">                                       </span><span class="c1">; return result of last sub-expression (numeric)</span>
<span class="w">   </span><span class="kr">If</span><span class="w"> </span>FORM<span class="w"> </span><span class="o">=</span><span class="w"> </span>b<span class="w">                         </span><span class="c1">; convert output to binary</span>
<span class="w">      </span>y<span class="w"> </span><span class="o">:=</span><span class="w"> </span>W<span class="w"> </span><span class="o">?</span><span class="w"> </span>Eval_ToBinW<span class="p">(</span>Round<span class="p">(</span>y<span class="p">),</span>W<span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span>Eval_ToBin<span class="p">(</span>Round<span class="p">(</span>y<span class="p">))</span>
<span class="w">   </span><span class="k">Else</span><span class="w"> </span><span class="nf">If</span><span class="w"> </span><span class="p">(</span>FORM<span class="o">=</span><span class="s">&quot;h&quot;</span><span class="w"> </span><span class="kr">or</span><span class="w"> </span>FORM<span class="o">=</span><span class="s">&quot;x&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">SetFormat</span><span class="w"> </span>Integer<span class="p">,</span><span class="w"> </span>Hex<span class="w">           </span><span class="c1">; convert output to hex</span>
<span class="w">      </span>y<span class="w"> </span><span class="o">:=</span><span class="w"> </span>Round<span class="p">(</span>y<span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">Else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span>W<span class="w"> </span><span class="o">:=</span><span class="w"> </span>W<span class="o">=</span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;0.6g&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;0.&quot;</span><span class="w"> </span><span class="p">.</span><span class="w"> </span>W<span class="w">    </span><span class="c1">; Set output form, Default = 6 decimal places</span>
<span class="w">      </span><span class="k">SetFormat</span><span class="w"> </span>FLOAT<span class="p">,</span><span class="w"> </span><span class="nv">%W%</span>
<span class="w">      </span>y<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">SetFormat</span><span class="w"> </span>Integer<span class="p">,</span><span class="w"> </span><span class="nv">%FormI%</span><span class="w">          </span><span class="c1">; restore original formats</span>
<span class="w">   </span><span class="k">SetFormat</span><span class="w"> </span>FLOAT<span class="p">,</span><span class="w">   </span><span class="nv">%FormF%</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>y
<span class="p">}</span>

<span class="nf">Eval_1</span><span class="p">(</span>x<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                             </span><span class="c1">; recursive PREPROCESSING of :=, vars, (..) [decimal, no &quot;;&quot;]</span>
<span class="w">   </span><span class="kt">Local</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>y<span class="p">,</span><span class="w"> </span>y1<span class="p">,</span><span class="w"> </span>y2<span class="p">,</span><span class="w"> </span>y3
<span class="w">                                       </span><span class="c1">; save function definition: f(x) := expr</span>
<span class="w">   </span><span class="kr">If</span><span class="w"> </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(\S*?)\((.*?)\)\s*:=\s*(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span>f<span class="nv">%y1%</span>__X<span class="w"> </span><span class="o">:=</span><span class="w"> </span>y2<span class="p">,</span><span class="w"> </span>f<span class="nv">%y1%</span>__F<span class="w"> </span><span class="o">:=</span><span class="w"> </span>y3
<span class="w">      </span><span class="k">Return</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">                                       </span><span class="c1">; execute leftmost &quot;:=&quot; operator of a := b := ...</span>
<span class="w">   </span><span class="kr">If</span><span class="w"> </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(\S*?)\s*:=\s*(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span>y<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="w"> </span><span class="p">.</span><span class="w"> </span>y1<span class="w">                    </span><span class="c1">; user vars internally start with x to avoid name conflicts</span>
<span class="w">      </span><span class="k">Return</span><span class="w"> </span><span class="nv">%y%</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>Eval_1<span class="p">(</span>y2<span class="p">)</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">                                       </span><span class="c1">; here: no variable to the left of last &quot;:=&quot;</span>
<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;([\).\w]\s+|[\)])([a-z_A-Z]+)&quot;</span><span class="p">,</span><span class="s">&quot;$1«$2»&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">; op -&gt; «op»</span>

<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;\s+&quot;</span><span class="p">)</span><span class="w">          </span><span class="c1">; remove spaces, tabs, newlines</span>

<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;([a-z_A-Z]\w*)\(&quot;</span><span class="p">,</span><span class="s">&quot;&#39;$1&#39;(&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; func( -&gt; &#39;func&#39;( to avoid atan|tan conflicts</span>

<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;([a-z_A-Z]\w*)([^\w&#39;»]|$)&quot;</span><span class="p">,</span><span class="s">&quot;%x$1%$2&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; VAR -&gt; %xVAR%</span>
<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;([^]*)%x[eE]%&quot;</span><span class="p">,</span><span class="s">&quot;$1e&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; in numbers %xe% -&gt; e</span>
<span class="w">   </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>RegExReplace<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;|&quot;</span><span class="p">)</span><span class="w">          </span><span class="c1">; no more need for number markers</span>
<span class="w">   </span><span class="k">Transform</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span>Deref<span class="p">,</span><span class="w"> </span><span class="nv">%x%</span><span class="w">             </span><span class="c1">; dereference all right-hand-side %var%-s</span>

<span class="w">   </span><span class="k">Loop</span><span class="w"> </span><span class="p">{</span><span class="w">                              </span><span class="c1">; find last innermost (..)</span>
<span class="w">      </span><span class="kr">If</span><span class="w"> </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*)\(([^\(\)]*)\)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">         </span>x<span class="w"> </span><span class="o">:=</span><span class="w"> </span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y2<span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="w"> </span>y3<span class="w">      </span><span class="c1">; replace (x) with value of x</span>
<span class="w">      </span><span class="k">Else</span><span class="w"> </span><span class="k">Break</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>x<span class="p">)</span>
<span class="p">}</span>

<span class="nf">Eval_@</span><span class="p">(</span>x<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                             </span><span class="c1">; EVALUATE PRE-PROCESSED EXPRESSIONS [decimal, NO space, vars, (..), &quot;;&quot;, &quot;:=&quot;]</span>
<span class="w">   </span><span class="kt">Local</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>y<span class="p">,</span><span class="w"> </span>y1<span class="p">,</span><span class="w"> </span>y2<span class="p">,</span><span class="w"> </span>y3<span class="p">,</span><span class="w"> </span>y4

<span class="w">   </span><span class="kr">If</span><span class="w"> </span>x<span class="w"> </span>is<span class="w"> </span>number<span class="w">                      </span><span class="c1">; no more operators left</span>
<span class="w">      </span><span class="k">Return</span><span class="w"> </span>x
<span class="w">                                       </span><span class="c1">; execute rightmost ?,: operator</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*)(\?|:)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">?</span><span class="p">,</span><span class="w">  </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;&quot;</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="w">  </span>Return<span class="w"> </span><span class="p">((</span>y<span class="w"> </span><span class="o">:=</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span>y<span class="p">)</span>

<span class="w">   </span><span class="k">StringGetPos</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">||</span><span class="p">,</span><span class="w"> </span>R<span class="w">            </span><span class="c1">; execute rightmost || operator</span>
<span class="w">   </span><span class="k">IfGreaterOrEqual</span><span class="w"> </span>i<span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">1</span><span class="p">,</span>i<span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">3</span><span class="o">+</span>i<span class="p">))</span>
<span class="w">   </span><span class="k">StringGetPos</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">,</span><span class="w"> </span>R<span class="w">            </span><span class="c1">; execute rightmost &amp;&amp; operator</span>
<span class="w">   </span><span class="k">IfGreaterOrEqual</span><span class="w"> </span>i<span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">1</span><span class="p">,</span>i<span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">3</span><span class="o">+</span>i<span class="p">))</span>
<span class="w">                                       </span><span class="c1">; execute rightmost =, &lt;&gt; operator</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*)(?&lt;![\&lt;\&gt;])(\&lt;\&gt;|=)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">=</span><span class="p">,</span><span class="w">  </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">  </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="w"> </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">                                       </span><span class="c1">; execute rightmost &lt;,&gt;,&lt;=,&gt;= operator</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*)(?&lt;![\&lt;\&gt;])(\&lt;=?|\&gt;=?)(?![\&lt;\&gt;])(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">&lt;</span><span class="p">,</span><span class="w">  </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w">  </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">&gt;</span><span class="p">,</span><span class="w">  </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w">  </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">&lt;=</span><span class="p">,</span><span class="w"> </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">&gt;=</span><span class="p">,</span><span class="w"> </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">                                       </span><span class="c1">; execute rightmost user operator (low precedence)</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;i)(.*)«(.*?)»(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">   </span><span class="kr">If</span><span class="w"> </span><span class="nf">IsFunc</span><span class="p">(</span>y2<span class="p">)</span>
<span class="w">      </span><span class="k">Return</span><span class="w"> </span><span class="nv">%y2%</span><span class="p">(</span><span class="nf">Eval_@</span><span class="p">(</span>y1<span class="p">),</span><span class="nf">Eval_@</span><span class="p">(</span>y3<span class="p">))</span><span class="w"> </span><span class="c1">; predefined relational ops</span>

<span class="w">   </span><span class="k">StringGetPos</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="p">,</span><span class="w"> </span>R<span class="w">             </span><span class="c1">; execute rightmost | operator</span>
<span class="w">   </span><span class="k">IfGreaterOrEqual</span><span class="w"> </span>i<span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">1</span><span class="p">,</span>i<span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">2</span><span class="o">+</span>i<span class="p">))</span>
<span class="w">   </span><span class="k">StringGetPos</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="p">,</span><span class="w"> </span>R<span class="w">             </span><span class="c1">; execute rightmost ^ operator</span>
<span class="w">   </span><span class="k">IfGreaterOrEqual</span><span class="w"> </span>i<span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">1</span><span class="p">,</span>i<span class="p">))</span><span class="w"> </span><span class="o">^</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">2</span><span class="o">+</span>i<span class="p">))</span>
<span class="w">   </span><span class="k">StringGetPos</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span>R<span class="w">             </span><span class="c1">; execute rightmost &amp; operator</span>
<span class="w">   </span><span class="k">IfGreaterOrEqual</span><span class="w"> </span>i<span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">1</span><span class="p">,</span>i<span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">2</span><span class="o">+</span>i<span class="p">))</span>
<span class="w">                                       </span><span class="c1">; execute rightmost &lt;&lt;, &gt;&gt; operator</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*)(\&lt;\&lt;|\&gt;\&gt;)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">&lt;&lt;</span><span class="p">,</span><span class="w"> </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"> </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">                                       </span><span class="c1">; execute rightmost +- (not unary) operator</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*[^!\~±¬\@\*/\\])(±|¬)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span><span class="w"> </span><span class="c1">; lower precedence ops already handled</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="err">±</span><span class="p">,</span><span class="w">  </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="err">¬</span><span class="p">,</span><span class="w">  </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">                                       </span><span class="c1">; execute rightmost */% operator</span>
<span class="w">   </span><span class="nf">RegExMatch</span><span class="p">(</span>x<span class="p">,</span><span class="w"> </span><span class="s">&quot;(.*)(\*|/|\\)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="w">  </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">/</span><span class="p">,</span><span class="w">  </span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,\,</span><span class="w">  </span><span class="k">Return</span><span class="w"> </span><span class="nf">Mod</span><span class="p">(</span>Eval_<span class="err">@</span><span class="p">(</span>y1<span class="p">),</span>Eval_<span class="err">@</span><span class="p">(</span>y3<span class="p">))</span>
<span class="w">                                       </span><span class="c1">; execute rightmost power</span>
<span class="w">   </span><span class="k">StringGetPos</span><span class="w"> </span>i<span class="p">,</span><span class="w"> </span>x<span class="p">,</span><span class="w"> </span><span class="err">@</span><span class="p">,</span><span class="w"> </span>R
<span class="w">   </span><span class="k">IfGreaterOrEqual</span><span class="w"> </span>i<span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">1</span><span class="p">,</span>i<span class="p">))</span><span class="w"> </span><span class="o">**</span><span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>SubStr<span class="p">(</span>x<span class="p">,</span><span class="mi">2</span><span class="o">+</span>i<span class="p">))</span>
<span class="w">                                       </span><span class="c1">; execute rightmost function, unary operator</span>
<span class="w">   </span><span class="kr">If</span><span class="w"> </span><span class="o">!</span>RegExMatch<span class="p">(</span>x<span class="p">,</span><span class="s">&quot;(.*)(!|±|¬|~|&#39;(.*)&#39;)(.*)&quot;</span><span class="p">,</span><span class="w"> </span>y<span class="p">)</span>
<span class="w">      </span><span class="k">Return</span><span class="w"> </span>x<span class="w">                         </span><span class="c1">; no more function (y1 &lt;&gt; &quot;&quot; only at multiple unaries: --+-)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">!</span><span class="p">,</span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="o">!</span>y4<span class="p">)</span><span class="w"> </span><span class="c1">; unary !</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="err">±</span><span class="p">,</span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>y1<span class="w"> </span><span class="p">.</span><span class="w">  </span>y4<span class="p">)</span><span class="w"> </span><span class="c1">; unary +</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="err">¬</span><span class="p">,</span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="o">-</span>y4<span class="p">)</span><span class="w"> </span><span class="c1">; unary - (they behave like functions)</span>
<span class="w">   </span>IfEqual<span class="w"> </span>y2<span class="p">,</span><span class="o">~</span><span class="p">,</span>Return<span class="w"> </span>Eval_<span class="nf">@</span><span class="p">(</span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="o">~</span>y4<span class="p">)</span><span class="w"> </span><span class="c1">; unary ~</span>
<span class="w">   </span><span class="kr">If</span><span class="w"> </span><span class="nf">IsFunc</span><span class="p">(</span>y3<span class="p">)</span>
<span class="w">      </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="nv">%y3%</span><span class="p">(</span>y4<span class="p">))</span><span class="w">      </span><span class="c1">; built-in and predefined functions(y4)</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span><span class="nf">Eval_@</span><span class="p">(</span>y1<span class="w"> </span><span class="p">.</span><span class="w"> </span>Eval_1<span class="p">(</span>RegExReplace<span class="p">(</span>f<span class="nv">%y3%</span>__F<span class="p">,</span><span class="w"> </span>f<span class="nv">%y3%</span>__X<span class="p">,</span><span class="w"> </span>y4<span class="p">)))</span><span class="w"> </span><span class="c1">; LAST: user defined functions</span>
<span class="p">}</span>

<span class="nf">Eval_ToBin</span><span class="p">(</span>n<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">      </span><span class="c1">; Binary representation of n. 1st bit is SIGN: -8 -&gt; 1000, -1 -&gt; 1, 0 -&gt; 0, 8 -&gt; 01000</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>n<span class="o">=</span><span class="mi">0</span><span class="o">||</span>n<span class="o">=-</span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">-</span>n<span class="w"> </span><span class="o">:</span><span class="w"> </span>Eval_ToBin<span class="p">(</span>n<span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="w"> </span>n<span class="o">&amp;</span><span class="mi">1</span>
<span class="p">}</span>
<span class="nf">Eval_ToBinW</span><span class="p">(</span>n<span class="p">,</span>W<span class="o">=</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">; LS W-bits of Binary representation of n</span>
<span class="w">   </span><span class="k">Loop</span><span class="w"> </span><span class="nv">%W%</span><span class="w">     </span><span class="c1">; Recursive (slower): Return W=1 ? n&amp;1 : ToBinW(n&gt;&gt;1,W-1) . n&amp;1</span>
<span class="w">      </span>b<span class="w"> </span><span class="o">:=</span><span class="w"> </span>n<span class="o">&amp;</span><span class="mi">1</span><span class="w"> </span><span class="p">.</span><span class="w"> </span>b<span class="p">,</span><span class="w"> </span>n<span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>b
<span class="p">}</span>
<span class="nf">Eval_FromBin</span><span class="p">(</span>bits<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">; Number converted from the binary &quot;bits&quot; string, 1st bit is SIGN</span>
<span class="w">   </span>n<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">   </span><span class="k">Loop</span><span class="w"> </span>Parse<span class="p">,</span><span class="w"> </span>bits
<span class="w">      </span>n<span class="w"> </span><span class="o">+=</span><span class="w"> </span>n<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">A_LoopField</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>n<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span>SubStr<span class="p">(</span>bits<span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span>StrLen<span class="p">(</span>bits<span class="p">))</span>
<span class="p">}</span>

<span class="nf">Eval_Sgn</span><span class="p">(</span>x<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="nf">Return</span><span class="w"> </span><span class="p">(</span>x<span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="p">(</span>x<span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">Eval_MIN</span><span class="p">(</span>a<span class="p">,</span>b<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>a<span class="o">&lt;</span>b<span class="w"> </span><span class="o">?</span><span class="w"> </span>a<span class="w"> </span><span class="o">:</span><span class="w"> </span>b
<span class="p">}</span>
<span class="nf">Eval_MAX</span><span class="p">(</span>a<span class="p">,</span>b<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>a<span class="o">&lt;</span>b<span class="w"> </span><span class="o">?</span><span class="w"> </span>b<span class="w"> </span><span class="o">:</span><span class="w"> </span>a
<span class="p">}</span>
<span class="nf">Eval_GCD</span><span class="p">(</span>a<span class="p">,</span>b<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">      </span><span class="c1">; Euclidean GCD</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>b<span class="o">=</span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span>Abs<span class="p">(</span>a<span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span>Eval_GCD<span class="p">(</span>b<span class="p">,</span><span class="w"> </span>mod<span class="p">(</span>a<span class="p">,</span>b<span class="p">))</span>
<span class="p">}</span>
<span class="nf">Eval_Choose</span><span class="p">(</span>n<span class="p">,</span>k<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">; Binomial coefficient</span>
<span class="w">   </span>p<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span>i<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>k<span class="w"> </span><span class="o">:=</span><span class="w"> </span>k<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>n<span class="o">-</span>k<span class="w"> </span><span class="o">?</span><span class="w"> </span>k<span class="w"> </span><span class="o">:</span><span class="w"> </span>n<span class="o">-</span>k
<span class="w">   </span><span class="k">Loop</span><span class="w"> </span><span class="nv">%k%</span><span class="w">                   </span><span class="c1">; Recursive (slower): Return k = 0 ? 1 : Choose(n-1,k-1)*n//k</span>
<span class="w">      </span>p<span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">(</span>n<span class="o">-</span>i<span class="p">)</span><span class="o">/</span><span class="p">(</span>k<span class="o">-</span>i<span class="p">),</span><span class="w"> </span>i<span class="o">+=</span><span class="mi">1</span><span class="w">  </span><span class="c1">; FOR INTEGERS: p *= n-i, p //= ++i</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span><span class="nf">Round</span><span class="p">(</span>p<span class="p">)</span>
<span class="p">}</span>

<span class="nf">Eval_Fib</span><span class="p">(</span>n<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">        </span><span class="c1">; n-th Fibonacci number (n &lt; 0 OK, iterative to avoid globals)</span>
<span class="w">   </span>a<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>b<span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">   </span><span class="k">Loop</span><span class="w"> </span><span class="o">%</span><span class="w"> </span>abs<span class="p">(</span>n<span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="w">      </span>c<span class="w"> </span><span class="o">:=</span><span class="w"> </span>b<span class="p">,</span><span class="w"> </span>b<span class="w"> </span><span class="o">+=</span><span class="w"> </span>a<span class="p">,</span><span class="w"> </span>a<span class="w"> </span><span class="o">:=</span><span class="w"> </span>c
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>n<span class="o">=</span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span>n<span class="o">&gt;</span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>n<span class="o">&amp;</span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span>b<span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">-</span>b
<span class="p">}</span>
<span class="nf">Eval_fac</span><span class="p">(</span>n<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">        </span><span class="c1">; n!</span>
<span class="w">   </span><span class="k">Return</span><span class="w"> </span>n<span class="o">&lt;</span><span class="mi">2</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span>n<span class="o">*</span>Eval_fac<span class="p">(</span>n<span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


New Lexer: 
<div class="highlight"><pre><span class="c-Singleline">;?add 2010 modified by Tuncay to make it stdlib conform. </span>
<span class="c-Singleline">;?add Outcommented lines from autoexecution section.</span>
<span class="c-Singleline">;?add Added the prefix Eval_ to all functions now. </span>
<span class="c-Singleline">;?add Eval1() becomes Eval_1() and Fib() becomes Eval_Fib().</span>
<span class="c-Singleline">;?add Originally by Laszlo at http://www.autohotkey.com/forum/viewtopic.php?t=17058</span>

<span class="c-Singleline">; MONSTER Version 1.2 to EVALUATE ARITHMETIC EXPRESSIONS in strings (needs AHK 1.0.48+)</span>
<span class="c-Singleline">; Containing HEX, Signed Binary (&#39;11 = -1, &#39;011 = 3), scientific numbers (1.2e+5)</span>
<span class="c-Singleline">; Assignments :=, preceding an expression. E.g: a:=1; b:=2; a+b</span>
<span class="c-Singleline">; User defined functions: f(x) := expr;</span>
<span class="c-Singleline">; AHK Functions Abs|Ceil|Exp|Floor|Log|Ln|Round|Sqrt|Sin|Cos|Tan|ASin|ACos|ATan</span>
<span class="c-Singleline">; Predefined functions: SGN|Fib|Fac (sign, Fibonacci numbers, Factorials)</span>
<span class="c-Singleline">; &#39;(&#39;,&#39;)&#39;; Variables; Predefined operators GCD,MIN,MAX,Choose (2-parameter functions)</span>
<span class="c-Singleline">; Predefined constants: e, pi, inch, foot, mile, ounce, pint, gallon, oz, lb;</span>
<span class="c-Singleline">; Logic operators: !, ||, &amp;&amp;; ternary operator: (_?_:_);</span>
<span class="c-Singleline">; Relations: =,&lt;&gt;; &lt;,&gt;,&lt;=,&gt;=</span>
<span class="c-Singleline">; Binary operators: ~; |, ^, &amp;, &lt;&lt;, &gt;&gt;</span>
<span class="c-Singleline">; Arithmetic operators: +, -; *, /, \ (or % = mod); ** (or @ = power)</span>
<span class="c-Singleline">; Output FORMAT: $x,$h: Hex; $b{W}: W-bit binary;</span>
<span class="c-Singleline">;    ${k}: k-digit fixpoint,  ${k}e,${k}g: k-digit scientific (Default $6g)</span>

<span class="c-Singleline">;?out-begin</span>
<span class="cm">/*</span>
<span class="cm">#SingleInstance Force</span>
<span class="cm">#NoEnv</span>
<span class="cm">SetBatchLines -1</span>
<span class="cm">Process Priority,,High</span>

<span class="cm">xe := 2.718281828459045, xpi := 3.141592653589793      ; referenced as &quot;e&quot;, &quot;pi&quot;</span>
<span class="cm">xinch := 2.54, xfoot := 30.48, xmile := 1.609344       ; [cm], [cm], [Km]</span>
<span class="cm">xounce := 0.02841, xpint := 0.5682, xgallon := 4.54609 ; liters</span>
<span class="cm">xoz := 28.35, xlb := 453.59237                         ; gramms</span>
<span class="cm">*/</span><span class="c-Singleline"></span>
<span class="c-Singleline">;?out-end</span>

<span class="cm">/* -test cases</span>
<span class="cm">MsgBox % Eval(&quot;1e1&quot;)                                               ; 10</span>
<span class="cm">MsgBox % Eval(&quot;0x1E&quot;)                                              ; 30</span>
<span class="cm">MsgBox % Eval(&quot;ToBin(35)&quot;)                                         ; 100011</span>
<span class="cm">MsgBox % Eval(&quot;$b 35&quot;)                                             ; 0100011</span>
<span class="cm">MsgBox % Eval(&quot;&#39;10010&quot;)                                            ; -14</span>
<span class="cm">MsgBox % Eval(&quot;2&gt;3 ? 9 : 7&quot;)                                       ; 7</span>
<span class="cm">MsgBox % Eval(&quot;$2E 1e3 -50.0e+0 + 100.e-1&quot;)                        ; 9.60E+002</span>
<span class="cm">MsgBox % Eval(&quot;fact(x) := x &lt; 2 ? 1 : x*fact(x-1); fact(5)&quot;)       ; 120</span>
<span class="cm">MsgBox % Eval(&quot;f(ab):=sqrt(ab)/ab; y:=f(2); ff(y):=y*(y-1)/2/x; x := 2; y+ff(3)/f(16)&quot;) ; 6.70711</span>
<span class="cm">MsgBox % Eval(&quot;x := qq:1; x := 5*x; y := x+1&quot;)                     ; 6 [if y empty, x := 1...]</span>
<span class="cm">MsgBox % Eval(&quot;x:=-!0; x&lt;0 ? 2*x : sqrt(x)&quot;)                       ; -2</span>
<span class="cm">MsgBox % Eval(&quot;tan(atan(atan(tan(1))))-exp(sqrt(1))&quot;)              ; -1.71828</span>
<span class="cm">MsgBox % Eval(&quot;---2+++9 + ~-2 --1 -2*-3&quot;)                          ; 15</span>
<span class="cm">MsgBox % Eval(&quot;x1:=1; f1:=sin(x1)/x1; y:=2; f2:=sin(y)/y; f1/f2&quot;)  ; 1.85082</span>
<span class="cm">MsgBox % Eval(&quot;Round(fac(10)/fac(5)**2) - (10 choose 5) + Fib(8)&quot;) ; 21</span>
<span class="cm">MsgBox % Eval(&quot;1 min-1 min-2 min 2&quot;)                               ; -2</span>
<span class="cm">MsgBox % Eval(&quot;(-1&gt;&gt;1&lt;=9 &amp;&amp; 3&gt;2)&lt;&lt;2&gt;&gt;1&quot;)                           ; 2</span>
<span class="cm">MsgBox % Eval(&quot;(1 = 1) + (2&lt;&gt;3 || 2 &lt; 1) + (9&gt;=-1 &amp;&amp; 3&gt;2)&quot;)        ; 3</span>
<span class="cm">MsgBox % Eval(&quot;$b6 -21/3&quot;)                                         ; 111001</span>
<span class="cm">MsgBox % Eval(&quot;$b (&#39;1001 &lt;&lt; 5) | &#39;01000&quot;)                          ; 100101000</span>
<span class="cm">MsgBox % Eval(&quot;$0 194*lb/1000&quot;)                                    ; 88 [Kg]</span>
<span class="cm">MsgBox % Eval(&quot;$x ~0xfffffff0 &amp; 7 | 0x100 &lt;&lt; 2&quot;)                   ; 0x407</span>
<span class="cm">MsgBox % Eval(&quot;- 1 * (+pi -((3%5))) +pi+ 1-2 + e-ROUND(abs(sqrt(floor(2)))**2)-e+pi $9&quot;) ; 3.141592654</span>
<span class="cm">MsgBox % Eval(&quot;(20+4 GCD abs(2**4)) + (9 GCD (6 CHOOSE 2))&quot;)       ; 11</span>
<span class="cm">t := A_TickCount</span>
<span class="cm">Loop 1000</span>
<span class="cm">   r := Eval(&quot;x:=&quot; A_Index/1000 &quot;;atan(x)-exp(sqrt(x))&quot;)           ; simulated plot</span>
<span class="cm">t := A_TickCount - t</span>
<span class="cm">MsgBox Result = %r%`nTime = %t%                                    ; -1.93288: ~400 ms [on Inspiron 9300]</span>
<span class="cm">*/</span><span class="c-Singleline"></span>

<span class="c-Singleline">;?out-begin</span>
<span class="cm">/*</span>
<span class="cm">^#-::                                  ; Replace selection or `expression with result</span>
<span class="cm">^#=::                                  ; Append result to selection or `expression</span>
<span class="cm">   ClipBoard =</span>
<span class="cm">   SendInput ^c                        ; copy selection</span>
<span class="cm">   ClipWait 0.5</span>
<span class="cm">   If (ErrorLevel) {</span>
<span class="cm">      SendInput +{HOME}^c              ; copy, keep selection to overwrite (^x for some apps)</span>
<span class="cm">      ClipWait 1</span>
<span class="cm">      IfEqual ErrorLevel,1, Return</span>
<span class="cm">      If RegExMatch(ClipBoard, &quot;(.*)(``)(.*)&quot;, y)</span>
<span class="cm">         SendInput %  &quot;{RAW}&quot; y1 . (A_ThisHotKey=&quot;^#=&quot; ? y3 . &quot; = &quot;  : &quot;&quot;) . Eval(y3)</span>
<span class="cm">   } Else</span>
<span class="cm">      SendInput % &quot;{RAW}&quot; . (A_ThisHotKey=&quot;^#=&quot; ? ClipBoard . &quot; = &quot;  : &quot;&quot;) . Eval(ClipBoard)</span>
<span class="cm">Return</span>
<span class="cm">*/</span><span class="c-Singleline"></span>
<span class="c-Singleline">;?out-end</span>

<span class="n">Eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">                              ; non-recursive PRE/POST PROCESSING: I/O forms, numbers, ops, &quot;;&quot;</span>
<span class="w">   </span><span class="nb">Local</span> <span class="n">FORM</span><span class="p">,</span> <span class="n">FormF</span><span class="p">,</span> <span class="n">FormI</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">y4</span>
   <span class="n">FormI</span> <span class="o">:=</span> <span class="nv">A_FormatInteger</span><span class="p">,</span> <span class="n">FormF</span> <span class="o">:=</span> <span class="nv">A_FormatFloat</span>

<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">D</span><span class="c-Singleline">                ; decimal intermediate results!</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;\$(b|h|x|)(\d*[eEgG]?)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
   <span class="n">FORM</span> <span class="o">:=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">W</span> <span class="o">:=</span> <span class="n">y2</span><span class="c-Singleline">                 ; HeX, Bin, .{digits} output format</span>
<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="mf">0.16</span><span class="n">e</span><span class="c-Singleline">              ; Full intermediate float precision</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">%y%</span><span class="c-Singleline">             ; remove $..</span>
<span class="w">   </span><span class="nb">Loop</span>
<span class="w">      </span><span class="nb">If </span><span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;i)(.*)(0x[a-f\d]*)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
         <span class="n">x</span> <span class="o">:=</span> <span class="n">y1</span> <span class="o">.</span> <span class="n">y2</span><span class="o">+</span><span class="mi">0</span> <span class="o">.</span> <span class="n">y3</span><span class="c-Singleline">           ; convert hex numbers to decimal</span>
<span class="w">      </span><span class="nb">Else</span> <span class="n">Break</span>
<span class="w">   </span><span class="nb">Loop</span>
<span class="w">      </span><span class="nb">If </span><span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)&#39;([01]*)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
         <span class="n">x</span> <span class="o">:=</span> <span class="n">y1</span> <span class="o">.</span> <span class="n">Eval_FromBin</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span> <span class="o">.</span> <span class="n">y3</span><span class="c-Singleline">    ; convert binary numbers to decimal: sign = first bit</span>
<span class="w">      </span><span class="nb">Else</span> <span class="n">Break</span>
   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;(^|[^.\d])(\d+)(e|E)&quot;</span><span class="p">,</span><span class="s">&quot;$1$2.$3&quot;</span><span class="p">)</span><span class="c-Singleline"> ; add missing &#39;.&#39; before E (1e3 -&gt; 1.e3)</span>
<span class="c-Singleline">                                       ; literal scientific numbers between  and  chars</span>
   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;(\d*\.\d*|\d)([eE][+-]?\d+)&quot;</span><span class="p">,</span><span class="s">&quot;$1$2&quot;</span><span class="p">)</span>

<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="se">`%</span><span class="p">,</span> \<span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; %  -&gt; \ (= MOD)</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="p">,</span><span class="n">@</span><span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; ** -&gt; @ for easier process</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">+</span><span class="p">,</span> <span class="err">±</span><span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; ± is addition</span>
   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([^]*)±&quot;</span><span class="p">,</span><span class="s">&quot;$1+&quot;</span><span class="p">)</span><span class="c-Singleline"> ; ...not inside literal numbers</span>
<span class="w">   </span><span class="nb">StringReplace</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="p">,</span> <span class="err">¬</span><span class="p">,</span> <span class="n">All</span><span class="c-Singleline">       ; ¬ is subtraction</span>
   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([^]*)¬&quot;</span><span class="p">,</span><span class="s">&quot;$1-&quot;</span><span class="p">)</span><span class="c-Singleline"> ; ...not inside literal numbers</span>

<span class="w">   </span><span class="nb">Loop</span> <span class="n">Parse</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="se">`;</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="n">Eval_1</span><span class="p">(</span><span class="nv">A_LoopField</span><span class="p">)</span><span class="c-Singleline">          ; work on pre-processed sub expressions</span>
<span class="c-Singleline">                                       ; return result of last sub-expression (numeric)</span>
<span class="w">   </span><span class="nb">If </span><span class="n">FORM</span> <span class="o">=</span> <span class="n">b</span><span class="c-Singleline">                         ; convert output to binary</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="n">W</span> <span class="o">?</span> <span class="n">Eval_ToBinW</span><span class="p">(</span><span class="nf">Round</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="n">W</span><span class="p">)</span> <span class="o">:</span> <span class="n">Eval_ToBin</span><span class="p">(</span><span class="nf">Round</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="w">   </span><span class="nb">Else</span> <span class="n">If</span> <span class="p">(</span><span class="n">FORM</span><span class="o">=</span><span class="s">&quot;h&quot;</span> <span class="ow">or</span> <span class="n">FORM</span><span class="o">=</span><span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="w">      </span><span class="nb">SetFormat</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Hex</span><span class="c-Singleline">           ; convert output to hex</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="nf">Round</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span>
   <span class="p">}</span>
<span class="w">   </span><span class="nb">Else</span> <span class="p">{</span>
      <span class="n">W</span> <span class="o">:=</span> <span class="n">W</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">?</span> <span class="s">&quot;0.6g&quot;</span> <span class="o">:</span> <span class="s">&quot;0.&quot;</span> <span class="o">.</span> <span class="n">W</span><span class="c-Singleline">    ; Set output form, Default = 6 decimal places</span>
<span class="w">      </span><span class="nb">SetFormat</span> <span class="n">FLOAT</span><span class="p">,</span> <span class="nv">%W%</span>
      <span class="n">y</span> <span class="o">+=</span> <span class="mf">0.0</span>
   <span class="p">}</span>
<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">Integer</span><span class="p">,</span> <span class="nv">%FormI%</span><span class="c-Singleline">          ; restore original formats</span>
<span class="w">   </span><span class="nb">SetFormat</span> <span class="n">FLOAT</span><span class="p">,</span>   <span class="nv">%FormF%</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">y</span>
<span class="p">}</span>

<span class="n">Eval_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">                             ; recursive PREPROCESSING of :=, vars, (..) [decimal, no &quot;;&quot;]</span>
<span class="w">   </span><span class="nb">Local</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; save function definition: f(x) := expr</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(\S*?)\((.*?)\)\s*:=\s*(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">f</span><span class="nv">%y1%</span><span class="n">__X</span> <span class="o">:=</span> <span class="n">y2</span><span class="p">,</span> <span class="n">f</span><span class="nv">%y1%</span><span class="n">__F</span> <span class="o">:=</span> <span class="n">y3</span>
<span class="w">      </span><span class="nb">Return</span>
   <span class="p">}</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute leftmost &quot;:=&quot; operator of a := b := ...</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(\S*?)\s*:=\s*(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="s">&quot;x&quot;</span> <span class="o">.</span> <span class="n">y1</span><span class="c-Singleline">                    ; user vars internally start with x to avoid name conflicts</span>
<span class="w">      </span><span class="nb">Return</span> <span class="nv">%y%</span> <span class="o">:=</span> <span class="n">Eval_1</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
   <span class="p">}</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; here: no variable to the left of last &quot;:=&quot;</span>
   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([\).\w]\s+|[\)])([a-z_A-Z]+)&quot;</span><span class="p">,</span><span class="s">&quot;$1«$2»&quot;</span><span class="p">)</span><span class="c-Singleline">  ; op -&gt; «op»</span>

   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;\s+&quot;</span><span class="p">)</span><span class="c-Singleline">          ; remove spaces, tabs, newlines</span>

   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([a-z_A-Z]\w*)\(&quot;</span><span class="p">,</span><span class="s">&quot;&#39;$1&#39;(&quot;</span><span class="p">)</span><span class="c-Singleline"> ; func( -&gt; &#39;func&#39;( to avoid atan|tan conflicts</span>

   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([a-z_A-Z]\w*)([^\w&#39;»]|$)&quot;</span><span class="p">,</span><span class="s">&quot;%x$1%$2&quot;</span><span class="p">)</span><span class="c-Singleline"> ; VAR -&gt; %xVAR%</span>
   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;([^]*)%x[eE]%&quot;</span><span class="p">,</span><span class="s">&quot;$1e&quot;</span><span class="p">)</span><span class="c-Singleline"> ; in numbers %xe% -&gt; e</span>
   <span class="n">x</span> <span class="o">:=</span> <span class="nf">RegExReplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;|&quot;</span><span class="p">)</span><span class="c-Singleline">          ; no more need for number markers</span>
<span class="w">   </span><span class="nb">Transform</span> <span class="n">x</span><span class="p">,</span> <span class="n">Deref</span><span class="p">,</span> <span class="nv">%x%</span><span class="c-Singleline">             ; dereference all right-hand-side %var%-s</span>

<span class="w">   </span><span class="nb">Loop</span> <span class="p">{</span><span class="c-Singleline">                              ; find last innermost (..)</span>
<span class="w">      </span><span class="nb">If </span><span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)\(([^\(\)]*)\)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
         <span class="n">x</span> <span class="o">:=</span> <span class="n">y1</span> <span class="o">.</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span> <span class="o">.</span> <span class="n">y3</span><span class="c-Singleline">      ; replace (x) with value of x</span>
<span class="w">      </span><span class="nb">Else</span> <span class="n">Break</span>
   <span class="p">}</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">Eval_@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">                             ; EVALUATE PRE-PROCESSED EXPRESSIONS [decimal, NO space, vars, (..), &quot;;&quot;, &quot;:=&quot;]</span>
<span class="w">   </span><span class="nb">Local</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">y4</span>

<span class="w">   </span><span class="nb">If </span><span class="n">x</span> <span class="ow">is</span> <span class="n">number</span><span class="c-Singleline">                      ; no more operators left</span>
<span class="w">      </span><span class="nb">Return</span> <span class="n">x</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost ?,: operator</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(\?|:)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">?</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">?</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&quot;</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">:</span><span class="p">,</span>  <span class="n">Return</span> <span class="p">((</span><span class="n">y</span> <span class="o">:=</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="o">?</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span> <span class="o">:</span> <span class="n">y</span><span class="p">)</span>

<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">||</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">            ; execute rightmost || operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">||</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">            ; execute rightmost &amp;&amp; operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost =, &lt;&gt; operator</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(?&lt;![\&lt;\&gt;])(\&lt;\&gt;|=)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">=</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">=</span>  <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost &lt;,&gt;,&lt;=,&gt;= operator</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(?&lt;![\&lt;\&gt;])(\&lt;=?|\&gt;=?)(?![\&lt;\&gt;])(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;</span>  <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&gt;</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&gt;</span>  <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;=</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&gt;=</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost user operator (low precedence)</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;i)(.*)«(.*?)»(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">IsFunc</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="w">      </span><span class="nb">Return</span> <span class="nv">%y2%</span><span class="p">(</span><span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span><span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">))</span><span class="c-Singleline"> ; predefined relational ops</span>

<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">|</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">             ; execute rightmost | operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">|</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">^</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">             ; execute rightmost ^ operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">R</span><span class="c-Singleline">             ; execute rightmost &amp; operator</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost &lt;&lt;, &gt;&gt; operator</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(\&lt;\&lt;|\&gt;\&gt;)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&lt;&lt;</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost +- (not unary) operator</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*[^!\~±¬\@\*/\\])(±|¬)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="c-Singleline"> ; lower precedence ops already handled</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="err">±</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="err">¬</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost */% operator</span>
   <span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;(.*)(\*|/|\\)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">*</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">/</span><span class="p">,</span>  <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span>\<span class="p">,</span>  <span class="n">Return</span> <span class="nf">Mod</span><span class="p">(</span><span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span><span class="n">Eval_@</span><span class="p">(</span><span class="n">y3</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost power</span>
<span class="w">   </span><span class="nb">StringGetPos</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">@</span><span class="p">,</span> <span class="n">R</span>
<span class="w">   </span><span class="nb">IfGreaterOrEqual</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="o">**</span> <span class="n">Eval_@</span><span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">))</span><span class="c-Singleline"></span>
<span class="c-Singleline">                                       ; execute rightmost function, unary operator</span>
   <span class="n">If</span> <span class="o">!</span><span class="nf">RegExMatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;(.*)(!|±|¬|~|&#39;(.*)&#39;)(.*)&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="w">      </span><span class="nb">Return</span> <span class="n">x</span><span class="c-Singleline">                         ; no more function (y1 &lt;&gt; &quot;&quot; only at multiple unaries: --+-)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">!</span><span class="p">,</span><span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="o">!</span><span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary !</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="err">±</span><span class="p">,</span><span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span> <span class="o">.</span>  <span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary +</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="err">¬</span><span class="p">,</span><span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="o">-</span><span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary - (they behave like functions)</span>
<span class="w">   </span><span class="nb">IfEqual</span> <span class="n">y2</span><span class="p">,</span><span class="o">~</span><span class="p">,</span><span class="n">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="o">~</span><span class="n">y4</span><span class="p">)</span><span class="c-Singleline"> ; unary ~</span>
<span class="w">   </span><span class="nb">If </span><span class="nf">IsFunc</span><span class="p">(</span><span class="n">y3</span><span class="p">)</span>
<span class="w">      </span><span class="nb">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="nv">%y3%</span><span class="p">(</span><span class="n">y4</span><span class="p">))</span><span class="c-Singleline">      ; built-in and predefined functions(y4)</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">Eval_@</span><span class="p">(</span><span class="n">y1</span> <span class="o">.</span> <span class="n">Eval_1</span><span class="p">(</span><span class="nf">RegExReplace</span><span class="p">(</span><span class="n">f</span><span class="nv">%y3%</span><span class="n">__F</span><span class="p">,</span> <span class="n">f</span><span class="nv">%y3%</span><span class="n">__X</span><span class="p">,</span> <span class="n">y4</span><span class="p">)))</span><span class="c-Singleline"> ; LAST: user defined functions</span>
<span class="p">}</span>

<span class="n">Eval_ToBin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">      ; Binary representation of n. 1st bit is SIGN: -8 -&gt; 1000, -1 -&gt; 1, 0 -&gt; 0, 8 -&gt; 01000</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="o">||</span><span class="n">n</span><span class="o">=-</span><span class="mi">1</span> <span class="o">?</span> <span class="o">-</span><span class="n">n</span> <span class="o">:</span> <span class="n">Eval_ToBin</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">.</span> <span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span>
<span class="p">}</span>
<span class="n">Eval_ToBinW</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline"> ; LS W-bits of Binary representation of n</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="nv">%W%</span><span class="c-Singleline">     ; Recursive (slower): Return W=1 ? n&amp;1 : ToBinW(n&gt;&gt;1,W-1) . n&amp;1</span>
      <span class="n">b</span> <span class="o">:=</span> <span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">.</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">b</span>
<span class="p">}</span>
<span class="n">Eval_FromBin</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline"> ; Number converted from the binary &quot;bits&quot; string, 1st bit is SIGN</span>
   <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="n">Parse</span><span class="p">,</span> <span class="n">bits</span>
      <span class="n">n</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">+</span> <span class="nv">A_LoopField</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="nf">SubStr</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="nf">StrLen</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span>
<span class="p">}</span>

<span class="n">Eval_Sgn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
<span class="w">   </span><span class="nb">Return</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">Eval_MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span>
<span class="p">}</span>
<span class="n">Eval_MAX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">b</span> <span class="o">:</span> <span class="n">a</span>
<span class="p">}</span>
<span class="n">Eval_GCD</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">      ; Euclidean GCD</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span> <span class="o">?</span> <span class="nf">Abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">Eval_GCD</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nf">mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="p">}</span>
<span class="n">Eval_Choose</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">   ; Binomial coefficient</span>
   <span class="n">p</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span> <span class="o">?</span> <span class="n">k</span> <span class="o">:</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="nv">%k%</span><span class="c-Singleline">                   ; Recursive (slower): Return k = 0 ? 1 : Choose(n-1,k-1)*n//k</span>
      <span class="n">p</span> <span class="o">*=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="c-Singleline">  ; FOR INTEGERS: p *= n-i, p //= ++i</span>
<span class="w">   </span><span class="nb">Return</span> <span class="nf">Round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">Eval_Fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">        ; n-th Fibonacci number (n &lt; 0 OK, iterative to avoid globals)</span>
   <span class="n">a</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="w">   </span><span class="nb">Loop</span> <span class="o">%</span> <span class="nf">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
      <span class="n">c</span> <span class="o">:=</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">c</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">?</span> <span class="n">b</span> <span class="o">:</span> <span class="o">-</span><span class="n">b</span>
<span class="p">}</span>
<span class="n">Eval_fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="c-Singleline">        ; n!</span>
<span class="w">   </span><span class="nb">Return</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span><span class="o">*</span><span class="n">Eval_fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
